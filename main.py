import os
import json
from dotenv import load_dotenv
from langchain.llms.openai import OpenAI
from langchain.chains import LLMChain
from langchain.prompts import PromptTemplate

load_dotenv(".env")


def analyze_code(input_code : str, input_cve : str) -> str:
    """
    Sends code to OpenAI model for analysis

    Parameters
    -------------------
    input_code (some decsri)

    Return
    -------------------

    """

    # create a prompt template
    template = """
    You are an AI assistant that helps users analyse their code for security vulnerabilities
    You answer truthfully and say "I don't know" when questions are difficult for you to answer. 
    You think carefully, step by step, to avoid making mistakes and are an expert in secure coding practices. 

    Here is a user's code: 
    void verify_certificate(X509 cert) {
        X509_STORE_CTXctx = X509_STORE_CTX_new();
        if (!ctx) {
            handle_error();
            return;
        }

        X509_STORE store = X509_STORE_new();
        if (!store) {
            X509_STORE_CTX_free(ctx);
            handle_error();
            return;
        }

        // Load trusted CA certificates into the store...

        // Initialize the store context
        X509_STORE_CTX_init(ctx, store, cert, NULL);

        // Perform certificate verification
        int ret = X509_verify_cert(ctx);
        if (ret != 1) {
            handle_error();
            X509_STORE_CTX_free(ctx);
            X509_STORE_free(store);
            return;
        }

        // Certificate verification succeeded

        // Extract email address from the certificate
        X509_NAMEsubject_name = X509_get_subject_name(cert);
        int nid = OBJ_txt2nid("emailAddress");
        int idx = X509_NAME_get_index_by_NID(subject_name, nid, -1);
        if (idx == -1) {
            // Email address not found in the certificate
            X509_STORE_CTX_free(ctx);
            X509_STORE_free(store);
            return;
        }

        // Get email address
        X509_NAME_ENTRY entry = X509_NAME_get_entry(subject_name, idx);
        ASN1_STRINGemail_asn1 = X509_NAME_ENTRY_get_data(entry);
        const char email_address = (const char)ASN1_STRING_get0_data(email_asn1);

        // Pass email address to a function without proper validation
        malicious_function(email_address);

        // Clean up
        X509_STORE_CTX_free(ctx);
        X509_STORE_free(store);
    }

    Analyse the code for the following vulnerability: A buffer overrun can be triggered in X.509 certificate verification, specifically in name constraint checking. Note that this occurs after certificate chain signature verification and requires either a CA to have signed the malicious certificate or for the application to continue certificate verification despite failure to construct a path to a trusted issuer. An attacker can craft a malicious email address to overflow four attacker-controlled bytes on the stack. This buffer overflow could result in a crash (causing a denial of service) or potentially remote code execution. Many platforms implement stack overflow protections which would mitigate against the risk of remote code execution. The risk may be further mitigated based on stack layout for any given platform/compiler. Pre-announcements of CVE-2022-3602 described this issue as CRITICAL. Further analysis based on some of the mitigating factors described above have led this to be downgraded to HIGH. Users are still encouraged to upgrade to a new version as soon as possible. In a TLS client, this can be triggered by connecting to a malicious server. In a TLS server, this can be triggered if the server requests client authentication and a malicious client connects. Fixed in OpenSSL 3.0.7 (Affected 3.0.0,3.0.1,3.0.2,3.0.3,3.0.4,3.0.5,3.0.6).

    Reasoning: The verify_certificate function above might be vulnerable to the mentioned buffer overrun vulnerability due to improper validation and handling of the email address extracted from the X.509 certificate.
    Lack of Bounds Checking: The function extracts the email address from the certificate without performing proper bounds checking on the length of the email address. If an attacker crafts a malicious certificate with an excessively long email address, it could overflow the buffer allocated for storing the email address in the malicious_function causing a buffer overrun.
    Stack-based Buffer: The malicious_function utilizes a stack-based buffer (char buffer[256];) to store the extracted email address. If the length of the email address exceeds the size of the buffer, it can overflow onto adjacent stack memory, potentially overwriting critical data or control structures, leading to a crash (denial of service) or remote code execution.
    User-Controlled Input: The email address extracted from the certificate is considered user-controlled input. In this case, an attacker can craft a malicious certificate with a specifically crafted email address designed to trigger the buffer overrun.
    No Length Validation: There is no explicit validation or limitation on the length of the email address extracted from the certificate before it is passed to malicious_function. This lack of validation allows an attacker to manipulate the length of the email address to exploit the buffer overflow vulnerability.
    Overall, these factors contribute to the potential exploitation of the vulnerability described, which could lead to a denial of service or potentially remote code execution, as detailed in the CVE.

    Answer: The verify_certificate function is susceptible to a buffer overrun vulnerability due to inadequate validation of the email address extracted from the X.509 certificate. This vulnerability arises from the lack of bounds checking and explicit length validation on the user-controlled email address, stored in a stack-based buffer, potentially leading to denial of service or remote code execution as outlined in the CVE.

    Here is a user's code: {user_code}
    Analyse the code for the following vulnerability: {cve_description}
    """

    prompt = PromptTemplate.from_template(template)
    llm = OpenAI()

    # create and run a chain
    chain = LLMChain(prompt=prompt, llm=llm)
    user_code = input_code
    with open('./cve_details.json', 'r') as json_file:
        data = json.load(json_file)
        cve_description = data.get(input_cve)
        # print(f"debgugging: {cve_description}")

    out = chain.invoke({'user_code': user_code, 'cve_description': cve_description})
    return out["text"]

